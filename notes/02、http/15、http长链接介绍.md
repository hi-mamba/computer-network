## [](https://www.jianshu.com/p/a697e504b1ab)

## [HTTP 长连接](https://www.kawabangga.com/posts/3322)

## [聊聊 TCP 长连接和心跳那些事](https://www.cnkirito.moe/tcp-talk/)

# http长链接介绍

HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。
HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),
但还是无状态的，或者说是不可以信任的。


## 长连接短连接操作过程

- 短连接的操作步骤是：
建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接

- 长连接的操作步骤是：
建立连接——数据传输...（保持连接）...数据传输——关闭连接

## 长连接与短连接
TCP 本身并没有长短连接的区别，长短与否，完全取决于我们怎么用它。

短连接：每次通信时，创建 Socket；一次通信结束，调用 socket.close()。这就是一般意义上的短连接，
短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。

长连接：每次通信完毕后，不会关闭连接，这样可以做到连接的复用。长连接的好处是省去了创建连接的耗时。

短连接和长连接的优势，分别是对方的劣势。想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理；想要追求性能，
使用长连接，我们就需要担心各种问题：比如端对端连接的维护，连接的保活。

长连接还常常被用来做数据的推送，我们大多数时候对通信的认知还是 request/response 模型，但 TCP 双工通信的性质决定了它还可以被用来做双向通信。
在长连接之下，可以很方便的实现 push 模型，长连接的这一特性在本文并不会进行探讨，有兴趣的同学可以专门去搜索相关的文章。

短连接没有太多东西可以讲，所以下文我们将目光聚焦在长连接的一些问题上。纯讲理论未免有些过于单调，
所以下文我借助一些 RPC 框架的实践来展开 TCP 的相关讨论

## 4. 长连接和短连接的优点和缺点
由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。
不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。

在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，
随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，
这样可 以避免一些恶意连接导致server端服务受损；

如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。
短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。
长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

## 5. 什么时候用长连接，短连接？
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，
再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。

例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，
而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，
而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。
 
 
 ## HTTP Keep-Alive Header
 [Hypertext Transfer Protocol (HTTP) Keep-Alive Header](https://tools.ietf.org/id/draft-thomson-hybi-http-timeout-01.html#rfc.section.1)
  这个 RFC 定义了 Keep-Alive Header 的一种形式。
 
 为什么需要这些参数呢？
 
 为了节省资源，Host 会选择关闭 idle 的长连接。比如一个连接很长时间没有使用，Host 会选择关闭它（显而易见）。
 
 基于这个原因，很多客户端发送非幂等的请求的时候，会选择不复用现有的 idle 连接。理由如下，假设现在有一个非幂等请求进来，
 而恰好 Server 认为这个连接空闲了很长时间了，决定要关闭此连接。那么客户端收不到 HTTP 响应（也可能收不到 TCP 的 ACK），
 客户端就不知道这个非幂等请求到底被处理了没有。可能 Server 收到了这个请求之后又关闭的，也可能请求到达之前 Server 就关闭连接了。
 
 所以很多客户端选择对所有非幂等请求都建立新的连接。但是每次都建立 TCP 连接，是很浪费资源的，也增加了请求的延迟。
 
 
 ## TCP Keepalive
 > TCP 本身并没有长短连接的区别，长短与否，完全取决于我们怎么用它。
 
 对于 TCP 来说，Keepalive 并不是标准 TCP 协议规定的，所以 TCP 本身并不知道这个东西的存在，这只是在 TCP 之上的一个实现。
 
 简单说，TCP Keepalive 就是设置一个 timer，时间一到就发送一个 probe packet，并设置 ACK。如果对方发送回来一个 ACK，
 那么那就知道这个 TCP 连接依然是可用的。如果对方没有发送 ACK 回来，那么就知道这个连接已经被断开了
 （实际的实现，一般会在收不到请求 ACK 的情况下重复发送多次 probe packet）。
 
 可以这么做是因为 
 
 1） TCP 是面向流的连接，
 而不是面向包的，所以在这个“流”中插入一个长度为 0 的包不会对这个流的内容造成任何影响。
 2）TCP 对每一个 packet 都会发送一个 ACK 确认。所以就可以用长度为 0 的一段“stream”来当做 probe。
 
 ### 那这个 TCP 的 Keepalive 有什么用呢？
 
 主要有两个，第一是检查连接是否可用。假设 TCP 的另一端断电了，或者中间的某一个转发的设备断电了，那么通过检查连接的可用性，
 就可以确保不会在一个已经不能用的连接上发消息，不会有 false-positive。
 
 第二是可以起到类似心跳的作用，防火墙或 NAT 设备的内存只能保存有限的连接数，它们普遍采用的策略是保留最近用到的连接，
 丢弃最旧没有有消息的连接。通过 Keepalive 的机制，我们可以让 NAT 设备保持我们的连接在可用列表中。
 
 对比一下：HTTP 的 Keep-Alive Header 做的是设置长连接的 idle 时间，超过了这个时间就关闭连接，
 TCP Keepalive 设置的 timer 到了就发送空的 probe packet。
 
 最后再提一个 Nginx 里面的 keepalive 指令，这个指令就更加迷惑了，跟上面介绍的都不搭边。
 它表示的是：Nginx 与 upstream 之间保持最多多少个 idle 的长连接。这个 idle 很关键，比如 keepalive 100 ，
 那么收到 300 个请求的时候，Nginx 和 upstream 建立 300 个长连接，这 300 个请求结束后，又来了 50 个请求，
 那么只有 50 个长连接是工作的，idle 的连接就有 250 个，Nginx 会关闭 150 个。更具体的例子可以看[这里](https://skyao.gitbooks.io/learning-nginx/content/documentation/keep_alive.html)。
 
 
 
 ## 注意和 HTTP 的 KeepAlive 区别对待
 
 HTTP 协议的 KeepAlive 意图在于连接复用，同一个连接上串行方式传递请求-响应数据
 
 TCP 的 KeepAlive 机制意图在于保活、心跳，检测连接错误。
 这压根是两个概念。
  
 
 
 
 
